# JVM

## JVM은 무엇인가

자바 가상 머신 java virture machine의 약자로 자바 프로그램이 실행 되는 가상 컴퓨터를 의미 한다. 컴파일 된 바이트코드를 실행하는 역할을 하는데 몇 가지 특징이 있다.

**운영체제에 독립적**

일반적으로 프로그램을 컴파일 하면 컴파일 운영체제와 타겟 운영체제과 다를 경우 프로그램이 정상적으로  동작 하지 않을 수 있다, 다른 운영체제에서도 프로그램을 실행하기 위해서는 크로스컴파일 등의 수정 작업이 필요한데, 자바로 작성한 프로그램은 수정 작업을 거치지 않고도 여러 운영체제에서 실행이 가능 하다. 

 일반 애플리케이션은 운영체제 위에서 실행이 되는데 java 프로그램은 JVM위에서 실행 되고 JVM은 운영체제 위에서 실행된다,따라서 타겟 운영체제에 해당하는 JVM만 설치해 준다면 java 프로그램은 운영체제와 독립적으로 실행가능 하다. 이런 원리로 java 프로그램은 모든 운영체제에서 실행이 가능하다. 

(정확히는 JVM이 동작할 수 있는 모든 운영체제에서...)

**자동으로 메모리 관리**

c 나 c++에 경우 운영체제의 메모리에 직접 접근하기 때문에 free()를 선언해서 할당 받았던 메모리를 해제해 주어야한다. 그렇지 않을 시 메모리 누수(memory leak)가 발생하게 되고 그로인해 현재 프로그램뿐 아니라 다른 프로그램에도  문제가 생길 수 있다. 

java의 경우 JVM 가상 머신을 통해서 간접적으로 메모리 영역에 접근하게 되고, c언어에서의 malloc, free()등에 개발자가 메모리 동적할당 하던 작업을 JVM이 스스로 메모리 관리를 하게 되는데, 즉 사용자가 처리 해야 했던 부분을 JVM 가상머신이 자동으로 메모리 관리를 해준다는 것!! 이 기능을 가비지컬렉션(GC)이라고 한다.

**바이트코드 및 컴파일러**

자바 컴파일러는 자바로 작성 한 소스코드를 JVM이 읽을 수 있는 바이트 코드로 변환 시킨다. (컴파일러 형태는 javac이다.)

바이트 코드는 무엇인가? 

사용자가 작성한 고급언어를 가상머신이 읽고 실행하기 위해서는 가상머신이 인식하기 쉬운 코드로 변환하는 과정이 필요한데 이 변환된 코드를 바이트코드라고 한다.

java는 컴파일시 javac 컴파일러로 파일을 변환하여 JVM에 넘겨주는데

``javac filename.java`` -> `filename.class`

위 변환된 .class파일이 바이트코드이다. c언어에 어셈블리어와 비슷까리 한듯?

javac가 번역기의 기능이라면 jvm은 응당 실행 컴파일러가 있어야겠지

**JIT 컴파일러**

바이트코드로 변환하는 javac는 정적 컴파일러였다면, JIT은 런타임중 동작하는 동적 컴파일러이다.

JVM 실행엔진은 원래 인터프리터 방식을 사용했는데 인터프리터 방식은 느리다는 단점이 있다. 그걸 보완 하기 위해 나온 게JIT(Just_In_Time)컴파일러 인데 

실행 시점에 인터프리터 방식(한줄씩 해석 실행) 으로 코드들을 기계어로 변환하면 저장해 뒀다가, 해당 코드들(같은 함수가 여러 번 불리는 등)이 나올 때 변환된 기계어 코드를 재 사용 하여 매번 기계어 코드를 생성하는 것을 방지한다. JIT컴파일러는 바이트코드를 빠른 속도로 기계어로 변환할 수 있고 이런 과정이 코드가 실행되는 과정 중에 실시간으로 작동한다.

전체적인 구조는 다음과 같다.

![java컴파일러.png](./imgs/java컴파일러.png)

## JVM 구성요소

- garbage Collection(GC)
    
    자동으로 메모리 관리를 해주는 부분으로 정리되지 않은 메모리, 유효하지 않은 메모리 즉 더 이상 사용하지 않는 오브젝트들을 자동으로 메모리 해제를 시켜 준다. 다만 사람의 판단력을 갖춘것은 아니기에 모든 메모리누수를 완벽하게 잡아 내진 못할 수 도 있다. (어느 정도는 메모리 관리에 신경을 써야 한다..)
    
- Class Loader
    
    컴파일을 통해 .java에서 .class로 변경된 바이트코드를 JVM에 메모리 영역인 Runtime Data Areas로 로딩을 시켜준다.
    
- Execution Engine
    
    실행 엔진으로 클래스 로더가 바이트코드를  runtime data areas로 로딩을 시키고 완료되면 이것을 실행시켜주는 역할을 하는데 두 가지 방식을 사용한다
    
    1. interpreter(인터프리터)
        
        바이트 코드를 한 줄 씩 (명령어 단위)로 읽어서 실행 한다
        
    2. JIT(just_In_Time)
        
        인터프리터에 경우 코드를 한 줄 씩 읽기 때문에 느리다는 단점이 있는데 그것을 보완하기 위해 나온 컴파일러이다.

### Runtime Data areas

프로그램을 수행하기 위해서 운영체제에서 할당 받은 메모리 공간으로  메모리의 용도에 따라 5가지 영역으로 나누어져 있다.

- Method (모든 스레드가 공유하는 공간)
    
    JVM이 시작될 때 생성되는 공간, 바이트 코드가 이영역에 저장된다. 클래스, 변수, static으로 선언한 공유 변수가 저장 된다. 
    
- Heap (모든 스레드가 공유하는 공간)
    
    동적으로 생성 된 객체가 저장되는 곳으로 GC의 대상이 되는 공간
    
- Stack
    
    지역 변수, 메서스의 매개변수, 임시적으로 사용되는 변수, 메서드 정보가 저장되는 영역으로 해당 메서드의 호출이 종료되면 이 안에 선언된 변수들은 사라진다, 금방 사용 되거나 사용이 끝나는 데이터들이 저장되는 영역
    
- PC register
    
    스레드가 시작될 때 생성 되는 공간,현재 수행중인 JVM 주소와 명령어를 저장 한다.
    
- Native Method
    
    자바 외 언어로 작성 된 네이티브 코드를 위한 메모리 영역


### GC 동작원리


**Mark and Sweep**

GC는 heap메모리 구조에서 참조되고 있지 않는 객체들을 대상으로 동작한다.

그렇기 때문에 GC는 객체의 참조여부를 판단해야 하는데 이때 Mark and Sweep 알고리즘을 사용한다.

1단계 : Mark

참조 되고 있는 객체들을 대상으로 마크를 찍는 단계이다.

우선 객체가 생성되면 0(false)으로 표시비트를 남긴다.

마크단계에선 루트 노드로 부터 연결된 객체들의 표시비트를 전부 1로 바꾼다.

루트 노드는 프로그램 실행 중 접근 가능한 객체들을 의미하며 루트 노드의 조건은 아래와 같다.

1. 스택 프레임 (현재 실행중인 메소드의 로컬 변수)
2. static 변수 (정적 변수의 수명은 == 프로그램 수명)
3. JNI (JNI는 Java와 외부 네이티브 언어를 매핑하는 인터페이스인데 이 때 네이티브 코드가 참조하는 java 객체는 루트노드 취급)

추가로 실행중인 Thread, 레지스터 등이 포함될 수 도 있다.

모든 루트 노드들에 아래 처럼 코드를 돌리며 현재 루트 노드와 연결된 모든 객체들의 표시비트를 1(true)로 바꾸는게 Mark 단계이다. 

```
Mark(root)
If markedBit(root) = false then
                     markedBit(root) = true
                                       For each v referenced by root
                                       Mark(v)
```

2 단계 : Sweep

숙청의 시간 마크가 찍히지 않은 객체들을 청소하는 단계

```
Sweep()
p는 heap 영역에 있는 각각의 모든 객체들을 의미한다. 
If markedBit(p) = true then
                  markedBit(p) = false
                                 else
                                     heap.release(p)
```

마크가 1이면 마크를 0으로 바꾸고 넘어감,
마크가 0이면 객체를 제거한다.

위 2단계를 진행함으로 객체의 참조 여부를 판단할 수 있다.


**동작 시점**

heap의 메모리 구조는 young과 old 2가지 영역이 존재한다. 

1. young 영역
    young 영역은 다시 eden, survival0, survival1 3가지 영역으로 구분된다.
    * eden

        new 등을 통해 생성된 객체가 저장되는 영역이다.
        이 영역이 가득차게 되면 GC가 발생하게 되고 이를 Minor GC라고 한다.

        GC 발생 이후 살아남은 객체들은 survival 영역으로 보내진다.
    * survival0 & survival1
  
        한번 이상의 GC에서 살아남은 객체들이 저장된다. 
        survival 0과 1 두 영역중 한군데는 반드시 비어있어야 하는데 GC가 발생할 때 eden에서 넘어온 객체와 survival 0또는 1에 있던 객체들을 모아서 비어있는 survival 영역으로 전부 이동시킨다.
        이때 살아남은 객체들은 age가 하나씩 올라간다.

2. old 영역

    Minor GC가 발생할 때마다 살아남은 객체의 age가 일정 임계값을 넘기면 오게되는 영역이다. 오래 살아남은 객체들만 넘어오는 경로당으로 young 영역보다 메모리 공간이 크게 할당된다. 

    old 영역 또한 가득차면 GC가 발생하는데 이를 Major GC 또는 Full GC 라고 부른다. 
    
    old 영역이 공간이 더 크기 때문에 Minor GC보다 Major GC가 시간이 더 오래걸린다,

JVM 은 GC가 실행될 때 GC를 제외한 다른 모든 동작을 멈춘다.

이를 STW(Stop The World) 라고 하는데 (이름 참 직관적이네)

GC가 자주 발생하면 프로그램이 자꾸 멈추기 때문에 성능에 악영향을 끼치게 된다.

특히 Major GC 가 자주 발생하지 않도록 안쓰는 변수들은 참조를 즉시 해제주면 좋겠다. 

**종류**

java 발전과 함께 상황에 따라 최적화가 가능한 여러 GC 알고리즘들이 개발되어 왔다.

Eplison, Shenandoah, ZGC, G1, Parallel ....Etc

많은 종류의 GC 알고리즘이 있고 설정을 통해 java에 적용해 줄 수 있다.

실시간 성 또는 성능이 중요한 프로그램을 구현해야 한다면 상황에 맞는 GC 알고리즘을 선택해서 적용하는게 중요하다 볼 수 있겠다.






https://www.geeksforgeeks.org/mark-and-sweep-garbage-collection-algorithm/